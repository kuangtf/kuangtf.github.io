<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="分布式总结, Maple">
    <meta name="description" content="人生如逆旅 我亦是行人">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>分布式总结 | Maple</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Maple" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/back.png);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Maple</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Maple</div>
        <div class="logo-desc">
            
            人生如逆旅 我亦是行人
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/kuangtf" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/kuangtf" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/medias/featureimages/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">分布式总结</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%80%BB%E7%BB%93/">
                                <span class="chip bg-color">分布式总结</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-category">
                                分布式
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-06-07
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-06-07
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    15.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    52 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="一-分布式理论"><a href="#一-分布式理论" class="headerlink" title="一.分布式理论"></a>一.分布式理论</h1><h2 id="1-分布式架构系统回顾"><a href="#1-分布式架构系统回顾" class="headerlink" title="1.分布式架构系统回顾"></a>1.分布式架构系统回顾</h2><h3 id="1）分布式系统概念"><a href="#1）分布式系统概念" class="headerlink" title="1）分布式系统概念"></a>1）分布式系统概念</h3><blockquote>
<p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调<br>的系统。</p>
</blockquote>
<p>俗的理解，所谓分布式系统，就是一个业务拆分成多个子业务，分布在不同的服务器节点，共同构成的系统称为分<br>布式系统，同一个分布式系统中的服务器节点在空间部署上是可以随意分布的，这些服务器可能放在不同的机柜<br>中，也可能在不同的机房中，甚至分布在不同的城市。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194352011.png" alt="image-20220606194352011" style="zoom:80%;">

<p>Tip：</p>
<p>分布式与集群的区别：</p>
<blockquote>
<p>集群：多个人在一起作同样的事 。<br>分布式 ：多个人在一起作不同的事 。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194317915.png" alt="image-20220606194317915" style="zoom:80%;">

<p>分布式系统的特点：</p>
<p>（1）分布性<br>（2）对等性<br>（3）并发性<br>（4）缺乏全局时钟<br>（5）故障总是会发生</p>
<h3 id="2）分布式系统的发展"><a href="#2）分布式系统的发展" class="headerlink" title="2）分布式系统的发展"></a>2）分布式系统的发展</h3><p>阿里巴巴发起的”去 IOE”运动 (IOE 指的是 IBM 小型机、Oracle 数据库、EMC 的高端存储)。阿里巴巴2009 年“去IOE”战略技术总监透露，截止到 2013 年 5 月 17 日阿里巴巴最后一台 IBM 小型机在支付宝下线。<br>为什么要去IOE<br>1.升级单机处理能力的性价比越来越低<br>2.单机处理能力存在瓶颈<br>3.稳定性和可用性这两个指标很难达到</p>
<h3 id="3）分布式架构的演变"><a href="#3）分布式架构的演变" class="headerlink" title="3）分布式架构的演变"></a>3）分布式架构的演变</h3><img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194506168.png" alt="image-20220606194506168" style="zoom:80%;">

<p><img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194519013.png" alt="image-20220606194519013"></p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194539979.png" alt="image-20220606194539979" style="zoom:80%;">

<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194558721.png" alt="image-20220606194558721" style="zoom:80%;">

<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194612662.png" alt="image-20220606194612662" style="zoom:80%;">

<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194628257.png" alt="image-20220606194628257" style="zoom:80%;">

<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194649565.png" alt="image-20220606194649565" style="zoom:80%;">

<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194809155.png" alt="image-20220606194809155" style="zoom:80%;">

<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194824739.png" alt="image-20220606194824739" style="zoom:80%;">

<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194837884.png" alt="image-20220606194837884" style="zoom:80%;">

<h2 id="2-分布式系统面临的问题"><a href="#2-分布式系统面临的问题" class="headerlink" title="2.分布式系统面临的问题"></a>2.分布式系统面临的问题</h2><p>1）通信异常<br>网络本身的不可靠性，因此每次网络通信都会伴随着网络不可用的风险（光纤、路由、DNS等硬件设备或系统的不可用），都会导致最终分布式系统无法顺利进行一次网络通信，另外，即使分布式系统各节点之间的网络通信能够正常执行，其延时也会大于单机操作，存在巨大的延时差别，也会影响消息的收发过程，因此消息丢失和消息延迟变的非常普遍。<br>2）网络分区<br>网络之间出现了网络不连通，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个<br>孤立的区域，分布式系统就会出现局部小集群，在极端情况下，这些小集群会独立完成原本需要整个分布式系统才<br>能完成的功能，包括数据的事务处理，这就对分布式一致性提出非常大的挑战。<br>3）节点故障<br>节点故障是分布式系统下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或”僵死”现象，<br>根据经验来说，每个节点都有可能出现故障，并且经常发生.<br>4）三态<br>分布式系统每一次请求与响应存在特有的“三态”概念，即成功、失败和超时。<br>分布式系统中，由于网络是不可靠的，虽然绝大部分情况下，网络通信能够接收到成功或失败的响应，但当网络出<br>现异常的情况下，就会出现超时现象，通常有以下两种情况：</p>
<ol>
<li>由于网络原因，该请求并没有被成功的发送到接收方，而是在发送过程就发生了丢失现象。</li>
<li>该请求成功的被接收方接收后，并进行了处理，但在响应反馈给发送方过程中，发生了消息丢失现象。</li>
</ol>
<h2 id="3-分布式理论：一致性"><a href="#3-分布式理论：一致性" class="headerlink" title="3.分布式理论：一致性"></a>3.分布式理论：一致性</h2><h3 id="1）什么是分布式一致性"><a href="#1）什么是分布式一致性" class="headerlink" title="1）什么是分布式一致性"></a>1）什么是分布式一致性</h3><p>分布式数据一致性，指的是数据在多份副本中存储时，各副本中的数据是一致的。</p>
<h3 id="2）副本一致性"><a href="#2）副本一致性" class="headerlink" title="2）副本一致性"></a>2）副本一致性</h3><p>分布式系统当中，数据往往会有多个副本。如果是一台数据库处理所有的数据请求，那么通过ACID四原则，基本<br>可以保证数据的一致性。而多个副本就需要保证数据会有多份拷贝。这就带来了同步的问题，因为我们几乎没有办<br>法保证可以同时更新所有机器当中的包括备份所有数据。 网络延迟，即使我在同一时间给所有机器发送了更新数据的请求，也不能保证这些请求被响应的时间保持一致存在时间差，就会存在某些机器之间的数据不一致的情况。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606194941849.png" alt="image-20220606194941849" style="zoom:67%;">

<p>总得来说，我们无法找到一种能够满足分布式系统所有系统属性的分布式一致性解决方案。因此，如何既保证数据<br>的一致性，同时又不影响系统运行的性能，是每一个分布式系统都需要重点考虑和权衡的。于是，一致性级别由此<br>诞生</p>
<h3 id="3）一致性分类"><a href="#3）一致性分类" class="headerlink" title="3）一致性分类"></a>3）一致性分类</h3><p>1、强一致性<br>这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往<br>对系统的性能影响大。但是强一致性很难实现。<br>2、弱一致性<br>这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，<br>但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</p>
<p><strong>读写一致性</strong></p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606195031027.png" alt="image-20220606195031027" style="zoom:80%;">

<blockquote>
<p>用户读取自己写入结果的一致性，保证用户永远能够第一时间看到自己更新的内容。<br>比如我们发一条朋友圈，朋友圈的内容是不是第一时间被朋友看见不重要，但是一定要显示在自己的列表上.<br>解决方案:<br>方案1：一种方案是对于一些特定的内容我们每次都去主库读取。 （问题主库压力大）<br>方案2：我们设置一个更新时间窗口，在刚刚更新的一段时间内，我们默认都从主库读取，过了这个窗口之后，我们会挑选最近有过更新的从库进行读取<br>方案3：我们直接记录用户更新的时间戳，在请求的时候把这个时间戳带上，凡是最后更新时间小于这个时间戳的从库都不予以响应。</p>
</blockquote>
<p><strong>单调读一致性</strong></p>
<blockquote>
<p>本次读到的数据不能比上次读到的旧。<br>由于主从节点更新数据的时间不一致，导致用户在不停地刷新的时候，有时候能刷出来，再次刷新之后会发现数据不见了，再刷新又可能再刷出来，就好像遇见灵异事件一样<br>解决方案:就是根据用户ID计算一个hash值，再通过hash值映射到机器。同一个用户不管怎么刷新，都只会被映射到同一台机器上。这样就保证了不会读到其他从库的内容，带来用户体验不好的影响。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606195120489.png" alt="image-20220606195120489" style="zoom:80%;">

<p><strong>因果一致性</strong></p>
<blockquote>
<p>指的是：如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。</p>
</blockquote>
<p><strong>最终一致性</strong></p>
<blockquote>
<p>最终一致性是所有分布式一致性模型当中最弱的。可以认为是没有任何优化的“最”弱一致性，它的意思是说，我不考虑所有的中间状态的影响，只保证当没有新的更新之后，经过一段时间之后，最终系统内所有副本的数据是正确的。它最大程度上保证了系统的并发能力，也因此，在高并发的场景下，它也是使用最广的一致性模型。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606195203285.png" alt="image-20220606195203285" style="zoom:80%;">

<h2 id="4-分布式理论：CAP定理"><a href="#4-分布式理论：CAP定理" class="headerlink" title="4.分布式理论：CAP定理"></a>4.分布式理论：CAP定理</h2><p><strong>CAP 定理</strong></p>
<blockquote>
<p>2000 年7月的时候，加州大学伯克利分校的Eric Brewer 教授提出了 CAP 猜想，2年后，被 来自于麻省理工<br>的Seth Gilbert 和 Nancy Lynch 从理论上证明了猜想的可能性，从此，CAP 定理正式在学术上成为了分布式计算领域的公认定理。并深深的影响了分布式计算的发展。</p>
</blockquote>
<p>CAP 理论含义是，一个分布式系统不可能同时满足一致性（C:Consistency)，可用性（A: Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的2个。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>C 一致性</td>
<td>分布式系统当中的一致性指的是所有节点的数据一致，或者说是所有副本的数据一致</td>
</tr>
<tr>
<td>A 可用性</td>
<td>Reads and writes always succeed. 也就是说系统一直可用，而且服务一直保持正常</td>
</tr>
<tr>
<td>P 分区容错性</td>
<td>系统在遇到一些节点或者网络分区故障的时候，仍然能够提供满足一致性和可用性的服务</td>
</tr>
</tbody></table>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606195346846.png" alt="image-20220606195346846" style="zoom:80%;">

<p>C - <strong>Consistency</strong><br>一致性是值写操作后读操作可以读到最新的数据状态,当数据分布在多个节点上时,从任意节点读取到的数据都是最<br>新的.商品信息读写要满足一致性需要实现如下目标:<br>1.商品服务写入主数据库成功, 则想从数据库查询数据也成功<br>2.商品服务写入主数据库失败,则向从数据库查询也失败<br>如何实现一致性?<br>1.写入主数据库后要数据同步到从数据库<br>2.写入主数据库后,在向从数据库同步期间要将从数据库锁定, 等待同步完成后在释放锁,以免在写新数据后,向从数据<br>库查询到旧的数据.<br>分布式一致性的特点:<br>1.由于存在数据库同步过程,写操作的响应会有一定的延迟<br>2.为了保定数据的一致性,对资源暂时锁定,待数据同步完成后释放锁定资源<br>3.如果请求数据同步失败的节点则会返回错误信息, 一定不会返回旧数据.<br>A - <strong>Availability</strong><br>可用性是指任何操作都可以得到响应的结果,且不会出现响应超时或响应错误。<br>商品信息读写要满足可用性需要实现如下目标:<br>1.从数据库接收到数据库查询的请求则立即能够响应数据查询结果<br>2.从数据库不允许出现响应超时或错误<br>如何实现可用性?<br>1.写入主数据库后要将数据同步到从数据<br>2.由于要保证数据库的可用性,不可以将数据库中资源锁定<br>3.即使数据还没有同步过来,从数据库也要返回查询数据, 哪怕是旧数据,但不能返回错误和超时.<br>P - <strong>Partition</strong> <strong>tolerance</strong><br>分布式系统的各个节点部署在不同的子网中, 不可避免的会出现由于网络问题导致节点之间通信失败,此时仍可以对<br>外提供服务, 这个就是分区容错性 (分区容忍性).<br>商品信息读写要满足分区容错性需要实现如下目标:<br>1.主数据库想从数据库同步数据失败不形象写操作<br>2.其中一个节点挂掉不会影响另一个节点对外提供服务<br>如何实现分区容错性?<br>1.尽量使用异步取代同步操作,举例 使用异步方式将数据从主数据库同步到从数据库, 这样节点之间能有效的实现松<br>耦合;<br>2.添加数据库节点,其中一个从节点挂掉,由其他从节点提供服务</p>
<p><strong>CAP只能 3 选 2</strong></p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606195501179.png" alt="image-20220606195501179" style="zoom:80%;">

<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606195517146.png" alt="image-20220606195517146" style="zoom:80%;">

<p>关于CAP这三个特性我们就介绍完了，接下来我们试着证明一下为什么CAP不能同时满足。</p>
<p>假设有一个系统如下：</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606195537011.png" alt="image-20220606195537011" style="zoom:80%;">

<pre class="line-numbers language-none"><code class="language-none">有用户向N1发送了请求更改了数据，将数据库从V0更新成了V1。由于网络断开，所以N2数据库依然是V0，如果这个时候
有一个请求发给了N2，但是N2并没有办法可以直接给出最新的结果V1，这个时候该怎么办呢？
这个时候无法两种方法，一种是将错就错，将错误的V0数据返回给用户。第二种是阻塞等待，等待网络通信恢复，N2中
的数据更新之后再返回给用户。显然前者牺牲了一致性，后者牺牲了可用性。
这个例子虽然简单，但是说明的内容却很重要。在分布式系统当中，CAP三个特性我们是无法同时满足的，必然要舍弃一
个。三者舍弃一个，显然排列组合一共有三种可能。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li><p>舍弃A(可用性)，保留CP(一致性和分区容错性)</p>
<pre class="line-numbers language-none"><code class="language-none">一个系统保证了一致性和分区容错性，舍弃可用性。也就是说在极端情况下，允许出现系统无法访问的情况出现，这个时候往往会牺牲用户体验，让用户保持等待，一直到系统数据一致了之后，再恢复服务。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>舍弃C(一致性)，保留AP(可用性和分区容错性)</p>
<pre class="line-numbers language-none"><code class="language-none">这种是大部分的分布式系统的设计，保证高可用和分区容错，但是会牺牲一致性。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>舍弃P(分区容错性)，保留CA(一致性和可用性)</p>
<pre class="line-numbers language-none"><code class="language-none">如果要舍弃P，那么就是要舍弃分布式系统，CAP也就无从谈起了。可以说P是分布式系统的前提，所以这种情况是不存在的。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="5-分布式理论：BASE-理论"><a href="#5-分布式理论：BASE-理论" class="headerlink" title="5.分布式理论：BASE 理论"></a>5.分布式理论：BASE 理论</h2><p>什么是BASE理论<br>BASE：全称：Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写，来自 ebay 的架构师提出。<br>BASE是对CAP中一致性和可用性权衡的结果，BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可<br>以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<p><strong>①Basically Available(基本可用)</strong></p>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。以下就是两个”基本可用”的例子</p>
<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出<br>现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li>
<li>功能上的损失：正常情况下，在一个电子商务网站（比如淘宝）上购物，消费者几乎能够顺利地完成每一笔<br>订单。但在一些节日大促购物高峰的时候（比如双十一、双十二），由于消费者的购物行为激增，为了保护<br>系统的稳定性（或者保证一致性），部分消费者可能会被引导到一个降级页面，如下：<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606195749419.png" alt="image-20220606195749419" style="zoom:80%;"></li>
</ul>
<p><strong>②Soft state（软状态）</strong></p>
<p>什么是软状态呢？相对于一致性，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。<br>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同<br>节点的数据副本之间进行数据同步的过程中存在延迟。</p>
<p><strong>③Eventually consistent（最终一致性）</strong><br>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此最终<br>一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<h2 id="6-分布式事务"><a href="#6-分布式事务" class="headerlink" title="6.分布式事务"></a>6.分布式事务</h2><h3 id="1-数据库事务回顾"><a href="#1-数据库事务回顾" class="headerlink" title="1) 数据库事务回顾"></a>1) 数据库事务回顾</h3><p><strong>事务的基本特性：</strong><br>我们知道事务有4个非常重要的特性，即我们常说的（ACID）。</p>
<p><strong>Atomicity（原子性）</strong>:是说事务是一个不可分割的整体，所有操作要么全做，要么全不做；只要事务中有一个操作<br>出错，回滚到事务开始前的状态的话，那么之前已经执行的所有操作都是无效的，都应该回滚到开始前的状态。<br><strong>Consistency（一致性）</strong>：是说事务执行前后，数据从一个状态到另一个状态必须是一致的，比如A向B转账（A、B的总金额就是一个一致性状态），不可能出现A扣了钱，B却没收到的情况发生。<br><strong>Isolation（隔离性）</strong>：多个并发事务之间相互隔离，不能互相干扰。关于事务的隔离性，可能不是特别好理解，<br>这里的并发事务是指两个事务操作了同一份数据的情况；而对于并发事务操作同一份数据的隔离性问题，则是要求<br>不能出现脏读、幻读的情况，即事务A不能读取事务B还没有提交的数据，或者在事务A读取数据进行更新操作时，不允许事务B率先更新掉这条数据。而为了解决这个问题，常用的手段就是加锁了，对于数据库来说就是通过数据<br>库的相关锁机制来保证。<br><strong>Durablity（持久性）</strong>：事务完成后，对数据库的更改是永久保存的。</p>
<h3 id="2-什么是分布式事务"><a href="#2-什么是分布式事务" class="headerlink" title="2) 什么是分布式事务"></a>2) 什么是分布式事务</h3><p>其实分布式事务从实质上看与数据库事务的概念是一致的，既然是事务也就需要满足事务的基本特性（ACID），只是分布式事务相对于本地事务而言其表现形式有很大的不同</p>
<h2 id="7-分布式理论：一致性协议-2PC"><a href="#7-分布式理论：一致性协议-2PC" class="headerlink" title="7.分布式理论：一致性协议 2PC"></a>7.分布式理论：一致性协议 2PC</h2><p>2）什么是 2PC<br>2PC （ Two-Phase Commit缩写）即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare<br>phase）、提交阶段（commit phase），2是指两个阶段，P是指准备阶段，C是指提交阶段。<br>在计算机中部分关系数据库如Oracle、MySQL支持两阶段提交协议.</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606200135372.png" alt="image-20220606200135372" style="zoom:80%;">

<p>两个阶段过程：</p>
<ol>
<li>准备阶段（Prepare phase）：事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事<br>务，并写本地的Undo/Redo日志，此时事务没有提交。 （Undo日志是记录修改前的数据，用于数据库回<br>滚，Redo日志是记录修改后的数据，用于提交事务后写入数 据文件）</li>
<li>提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意:必须在最后阶段释放锁资源。<br>协议说明：<br>顾名思义，二阶段提交就是将事务的提交过程分成了两个阶段来进行处理。流程如下</li>
</ol>
<h3 id="2）2PC执行流程"><a href="#2）2PC执行流程" class="headerlink" title="2）2PC执行流程"></a>2）2PC执行流程</h3><p><strong>成功执行事务事务提交流程</strong></p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606200224730.png" alt="image-20220606200224730" style="zoom:80%;">

<pre class="line-numbers language-none"><code class="language-none">阶段一:
1. 事务询问
协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。
2. 执行事务 (写本地的Undo/Redo日志)
3. 各参与者向协调者反馈事务询问的响应
总结: 各个参与者进行投票是否让事务进行.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Tip: 什么是Ack</p>
<blockquote>
<p>ACK 确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">阶段二:
1. 发送提交请求：
	协调者向所有参与者发出 commit 请求。
2. 事务提交：
	参与者收到 commit 请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资
源。
3. 反馈事务提交结果：
	参与者在完成事务提交之后，向协调者发送 Ack 信息。
4. 完成事务：
	协调者接收到所有参与者反馈的 Ack 信息后，完成事务。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>中断事务步骤如下：</strong></p>
<p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响<br>应，那么就会中断事务</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606200333316.png" alt="image-20220606200333316" style="zoom:80%;">

<p><strong>阶段一:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">1. 事务询问
	协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。
2. 执行事务 (写本地的Undo/Redo日志)
3. 各参与者向协调者反馈事务询问的响应
总结: 各个参与者进行投票是否让事务进行.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>阶段二:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">1. 发送回滚请求：
	协调者向所有参与者发出 Rollback 请求。
2. 事务回滚：
	参与者接收到 Rollback 请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。
3. 反馈事务回滚结果：
	参与者在完成事务回滚之后，向协调者发送 Ack 信息。
4. 中断事务：
	协调者接收到所有参与者反馈的 Ack 信息后，完成事务中断。
从上面的逻辑可以看出，二阶段提交就做了2个事情：投票，执行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3）2PC-优点缺点"><a href="#3）2PC-优点缺点" class="headerlink" title="3）2PC 优点缺点"></a>3）2PC 优点缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>原理简单，实现方便</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>同步阻塞，单点问题，数据不一致，过于保守</p>
<ul>
<li>同步阻塞：<br>二阶段提交协议存在最明显也是最大的一个问题就是同步阻塞，在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。</li>
<li>单点问题：<br>协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转，更重要的是：其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。</li>
<li>数据不一致：<br>假设当协调者向所有的参与者发送 commit 请求之后，发生了局部网络异常或者是协调者在尚未发送完所有<br>commit 请求之前自身发生了崩溃，导致最终只有部分参与者收到了 commit 请求。这将导致严重的数据不一致问题。</li>
<li>过于保守：<br>如果在二阶段提交的提交询问阶段中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点失败都会导致整个事务的失败。</li>
</ul>
<h2 id="8-分布式理论：一致性协议-3PC"><a href="#8-分布式理论：一致性协议-3PC" class="headerlink" title="8.分布式理论：一致性协议 3PC"></a>8.分布式理论：一致性协议 3PC</h2><h3 id="什么是三阶段提交"><a href="#什么是三阶段提交" class="headerlink" title="什么是三阶段提交"></a>什么是三阶段提交</h3><p>3PC，全称 “three phase commit”，是 2PC 的改进版，将 2PC 的 “提交事务请求” 过程一分为二，共形成了由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606200541019.png" alt="image-20220606200541019" style="zoom:80%;">

<h3 id="阶段一：CanCommit"><a href="#阶段一：CanCommit" class="headerlink" title="阶段一：CanCommit"></a>阶段一：CanCommit</h3><p>第一个阶段： CanCommit<br>    ① 事务询问<br>协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待<br>各参与者的响应。<br>    ② 各参与者向协调者反馈事务询问的响应<br>参与者在接收到来自协调者的包含了事务内容的canCommit请求后，正常情况下，如果自身认为可以顺利执行事<br>务，则反馈Yes响应，并进入预备状态，否则反馈No响应。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606200614371.png" alt="image-20220606200614371" style="zoom:80%;">

<h3 id="阶段二：PreCommit"><a href="#阶段二：PreCommit" class="headerlink" title="阶段二：PreCommit"></a>阶段二：PreCommit</h3><p>协调者在得到所有参与者的响应之后，会根据结果有2种执行操作的情况：执行事务预提交，或者中断事务<br>假如所有参与反馈的都是Yes，那么就会执行事务预提交。</p>
<ol>
<li>执行事务预提交分为 3 个步骤<br>① 发送预提交请求：<br>协调者向所有参与者节点发出preCommit请求，并进入prepared阶段。<br>② 事务预提交：<br>参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。<br>③ 各参与者向协调者反馈事务执行的结果：<br>若参与者成功执行了事务操作，那么反馈Ack<br>若任一参与者反馈了No响应，或者在等待超时后，协调者尚无法接收到所有参与者反馈，则中断事务</li>
<li>中断事务也分为2个步骤：<br>① 发送中断请求：<br>协调者向所有参与者发出abort请求。<br>② 中断事务：<br>无论是收到来自协调者的abort请求或者等待协调者请求过程中超时，参与者都会中断事务</li>
</ol>
<h3 id="阶段三：do-Commit"><a href="#阶段三：do-Commit" class="headerlink" title="阶段三：do Commit"></a>阶段三：do Commit</h3><img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606200706119.png" alt="image-20220606200706119" style="zoom:80%;">

<p>该阶段做真正的事务提交或者完成事务回滚，所以就会出现两种情况：</p>
<ol>
<li><p>执行事务提交<br>① 发送提交请求：<br>进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么他将从预提交状态转化为提交状态，并向所有的参与者发送doCommit请求。<br>② 事务提交：<br>参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行过程中占用的事务资源。<br>③ 反馈事务提交结果：<br>参与者在完成事务提交后，向协调者发送Ack响应。<br>④ 完成事务：<br>协调者接收到所有参与者反馈的Ack消息后，完成事务。</p>
</li>
<li><p>中断事务<br>① 发送中断请求：协调者向所有的参与者节点发送abort请求。<br>② 事务回滚：参与者收到abort请求后，会根据记录的Undo信息来执行事务回滚，并在完成回滚之后释放整<br>个事务执行期间占用的资源。<br>③ 反馈事务回滚结果：参与者在完成事务回滚后，向协调者发送Ack消息。<br>④ 中断事务：协调者接收到所有参与者反馈的Ack消息后，中断事务。</p>
</li>
</ol>
<p>  注意：一旦进入阶段三，可能会出现 2 种故障：</p>
<ul>
<li>协调者出现问题</li>
<li>协调者和参与者之间的网络故障</li>
</ul>
<p>  如果出现了任一一种情况，最终都会导致参与者无法收到 doCommit 请求或者 abort 请求，针对这种情况，参与者都会在等待超时之后，继续进行事务提交</p>
<h3 id="2PC对比3PC"><a href="#2PC对比3PC" class="headerlink" title="2PC对比3PC"></a>2PC对比3PC</h3><p>1.首先对于协调者和参与者都设置了超时机制（在2PC中，只有协调者拥有超时机制，即如果在一定时间内没有收<br>到参与者的消息则默认失败）,主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。 </p>
<p>2.通过CanCommit、PreCommit、DoCommit三个阶段的设<br>计，相较于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的 。</p>
<p>3.PreCommit是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的。</p>
<p>问题：3PC协议并没有完全解决数据不一致问题。</p>
<h2 id="9-分布式理论：一致性算法-Paxos"><a href="#9-分布式理论：一致性算法-Paxos" class="headerlink" title="9.分布式理论：一致性算法 Paxos"></a>9.分布式理论：一致性算法 Paxos</h2><h3 id="什么是Paxos算法"><a href="#什么是Paxos算法" class="headerlink" title="什么是Paxos算法"></a>什么是Paxos算法</h3><p>Paxos由Lamport于1998年在《The Part-Time Parliament》论文中首次公开，最初的描述使用希腊的一个小岛<br>Paxos作为比喻，描述了Paxos小岛中通过决议的流程，并以此命名这个算法，但是这个描述理解起来比较有挑战<br>性。后来在2001年，Lamport觉得同行不能理解他的幽默感，于是重新发表了朴实的算法描述版本《Paxos MadeSimple》</p>
<p>自Paxos问世以来就持续垄断了分布式一致性算法，Paxos这个名词几乎等同于分布式一致性。Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如Chubby、Megastore以及Spanner等。开源的<br>ZooKeeper，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。然而，Paxos的最大特点就是难，不仅难以理解，更难以实现。</p>
<h3 id="Paxos-解决了什么问题"><a href="#Paxos-解决了什么问题" class="headerlink" title="Paxos 解决了什么问题"></a>Paxos 解决了什么问题</h3><p>答：解决了分布式系统一致性问题</p>
<pre class="line-numbers language-none"><code class="language-none">分布式系统才用多副本进行存储数据 , 如果对多个副本执行序列不控制, 那多个副本执行更新操作,由于网络延迟 超时
等故障到值各个副本的数据不一致.
我们希望每个副本的执行序列是 [ op1 op2 op3 .... opn ] 不变的, 相同的.
Paxos 一次来确定不可变变量 opi的取值 , 每次确定完Opi之后,各个副本执行opi操作,一次类推。
结论： Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个
数据的值达成一致.
注：这里某个数据的值并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）。。。根据应用场
景不同，某个数据的值有不同的含义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606201044706.png" alt="image-20220606201044706" style="zoom:80%;">

<p>我们假设一种情况，在一个集群环境中，要求所有机器上的状态是一致的，其中有2台机器想修改某个状态，机器<br>A 想把状态改为 A，机器 B 想把状态改为 B，那么到底听谁的呢？<br>有的同学会想到，可以像 2PC，3PC 一样引入一个协调者，谁先到，听谁的</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606201105952.png" alt="image-20220606201105952" style="zoom:80%;">

<p>但是如果，协调者宕机了呢？<br>所以需要对协调者也做备份，也要做集群。这时候，问题来了，这么多协调者，听谁的呢？</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606201120216.png" alt="image-20220606201120216" style="zoom:80%;">

<p>Paxos 算法就是为了解决这个问题而生的</p>
<h3 id="Paxos相关概念"><a href="#Paxos相关概念" class="headerlink" title="Paxos相关概念"></a>Paxos相关概念</h3><p>首先一个很重要的概念叫提案（Proposal）。最终要达成一致的value就在提案里。<br>提案 (Proposal)：Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)<br>在Paxos算法中，有如下角色：</p>
<ul>
<li>Client：客户端<ul>
<li>客户端向分布式系统发出请求，并等待响应。例如，对分布式文件服务器中文件的写请求。</li>
</ul>
</li>
<li>Proposer：提案发起者<ul>
<li>提案者提倡客户请求，试图说服Acceptor对此达成一致，并在发生冲突时充当协调者以推动协议向前发<br>展</li>
</ul>
</li>
<li>Acceptor：决策者，可以批准提案<ul>
<li>Acceptor可以接受（accept）提案；如果某个提案被选定（chosen），那么该提案里的value就被选定<br>了</li>
</ul>
</li>
<li>Learners：最终决策的学习者<ul>
<li>学习者充当该协议的复制因素</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606201256630.png" alt="image-20220606201256630" style="zoom:80%;">

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设有一组可以提出提案的进程集合，那么对于一个一致性算法需要保证以下几点：</p>
<ul>
<li>在这些被提出的提案中，只有一个会被选定</li>
<li>如果没有提案被提出，就不应该有被选定的提案。</li>
<li>当一个提案被选定后，那么所有进程都应该能学习（learn）到这个被选定的value</li>
</ul>
<h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><h4 id="最简单的方案——只有一个Acceptor"><a href="#最简单的方案——只有一个Acceptor" class="headerlink" title="最简单的方案——只有一个Acceptor"></a>最简单的方案——只有一个Acceptor</h4><p>假设只有一个Acceptor（可以有多个Proposer），只要Acceptor接受它收到的第一个提案，则该提案被选定，该<br>提案里的value就是被选定的value。这样就保证只有一个value会被选定。<br>但是，如果这个唯一的Acceptor宕机了，那么整个系统就无法工作了！<br>因此，必须要有多个Acceptor！</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606201345776.png" alt="image-20220606201345776" style="zoom:80%;">

<h4 id="多个Acceptor"><a href="#多个Acceptor" class="headerlink" title="多个Acceptor"></a>多个Acceptor</h4><p>多个Acceptor的情况如下图。那么，如何保证在多个Proposer和多个Acceptor的情况下选定一个value呢？</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606201402817.png" alt="image-20220606201402817" style="zoom:80%;">

<p>下面开始寻找解决方案。<br>首先我们希望即使只有一个Proposer提出了一个value，该value也最终被选定。<br>那么，就得到下面的约束：</p>
<pre class="line-numbers language-none"><code class="language-none">P1：一个Acceptor必须接受它收到的第一个提案。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>但是，这又会引出另一个问题：如果每个Proposer分别提出不同的value，发给不同的Acceptor。根据P1，<br>Acceptor分别接受自己收到的第一个提案，就导致不同的value被选定。出现了不一致。如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606201433273.png" alt="image-20220606201433273" style="zoom:80%;">

<p>刚刚是因为『一个提案只要被一个Acceptor接受，则该提案的value就被选定了』才导致了出现上面不一致的问<br>题。因此，我们需要加一个规定：</p>
<pre class="line-numbers language-none"><code class="language-none">规定：一个提案被选定需要被半数以上的Acceptor接受<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个规定又暗示了：『一个Acceptor必须能够接受不止一个提案！』不然可能导致最终没有value被选定。比如上<br>图的情况。v1、v2、v3都没有被选定，因为它们都只被一个Acceptor的接受。<br>所以在这种情况下，我们使用一个全局的编号来标识每一个Acceptor批准的提案，当一个具有某value值的提案被<br>半数以上的Acceptor批准后，我们就认为该value被选定了.<br>根据上面的内容，我们现在虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值。否则<br>又会出现不一致。<br>于是有了下面的约束：</p>
<pre class="line-numbers language-none"><code class="language-none">P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p>
<pre class="line-numbers language-none"><code class="language-none">P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>只要满足了P2a，就能满足P2。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606201523564.png" alt="image-20220606201523564" style="zoom:80%;">

<p>但是，考虑如下的情况：假设总的有5个Acceptor。Proposer2提出[M1,V1]的提案，Acceptor2<del>5（半数以上）均接受了该提案，于是对于Acceptor2</del>5和Proposer2来讲，它们都认为V1被选定。Acceptor1刚刚从宕机状态恢复过来（之前Acceptor1没有收到过任何提案），此时Proposer1向Acceptor1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于Acceptor1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,Acceptor1必须接受该提案！同时Acceptor1认为V2被选定。这就出现了两个问题：</p>
<ol>
<li>Acceptor1认为V2被选定，Acceptor2~5和Proposer2认为V1被选定。出现了不一致。</li>
<li>V1被选定了，但是编号更高的被Acceptor1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li>
</ol>
<p>所以我们要对P2a约束进行强化！</p>
<p>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所有我们可以对Proposer提出的提案进行约束。得到P2b：</p>
<pre class="line-numbers language-none"><code class="language-none">P2b：如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案的value必须也是v。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>由P2b可以推出P2a进而推出P2。<br>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？<br>只要满足P2c即可：</p>
<pre class="line-numbers language-none"><code class="language-none">P2c：对于任意的Mn和Vn,如果提案[Mn,Vn]被提出，那么肯定存在一个由半数以上的Acceptor组成的集合S，满足以下
两个条件中的任意一个：
* 要么S中每个Acceptor都没有接受过编号小于Mn的提案。
* 要么S中所有Acceptor批准的所有编号小于Mn的提案中，编号最大的那个提案的value值为Vn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>从上面的内容，可以看出，从P1到P2c的过程其实是对一系列条件的逐步增强，如果需要证明这些条件可以保证一<br>致性，那么就可以进行反向推导：P2c =&gt;P2b=&gt;P2a=&gt;P2,然后通过P2和P1来保证一致性</p>
<h3 id="Proposer生成提案"><a href="#Proposer生成提案" class="headerlink" title="Proposer生成提案"></a>Proposer生成提案</h3><p>接下来来学习，在P2c的基础上如何进行提案的生成<br>这里有个比较重要的思想：Proposer生成提案之前，应该先去『学习』已经被选定或者可能被选定的value，然后<br>以该value作为自己提出的提案的value。如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个『Prepare请求』实现的。<br>于是我们得到了如下的提案生成算法：</p>
<ol>
<li>Proposer选择一个新的提案编号N，然后向某个Acceptor集合（半数以上）发送请求，要求该集合中的每个<br>Acceptor做出如下响应（response）<br>(a) Acceptor向Proposer承诺保证不再接受任何编号小于N的提案。<br>(b) 如果Acceptor已经接受过提案，那么就向Proposer反馈已经接受过的编号小于N的，但为最大编号的提案的值。</li>
</ol>
<p>我们将该请求称为编号为N的Prepare请求。</p>
<ol>
<li>如果Proposer收到了半数以上的Acceptor的响应，那么它就可以生成编号为N，Value为V的提案[N,V]。这里的V是所有的响应中编号最大的提案的Value。如果所有的响应中都没有提案，那 么此时V就可以由Proposer自己选择。生成提案后，Proposer将该提案发送给半数以上的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为Accept请求。</li>
</ol>
<h3 id="Acceptor接受提案"><a href="#Acceptor接受提案" class="headerlink" title="Acceptor接受提案"></a>Acceptor接受提案</h3><p>刚刚讲解了Paxos算法中Proposer的处理逻辑，怎么去生成的提案，下面来看看Acceptor是如何批准提案的<br>根据刚刚的介绍，一个Acceptor可能会受到来自Proposer的两种请求，分别是Prepare请求和Accept请求，对这两类请求作出响应的条件分别如下</p>
<ul>
<li>Prepare请求：Acceptor可以在任何时候响应一个Prepare请求</li>
<li>Accept请求：在不违背Accept现有承诺的前提下，可以任意响应Accept请求</li>
</ul>
<p>因此，对Acceptor接受提案给出如下约束：</p>
<blockquote>
<p>P1a：一个Acceptor只要尚未响应过任何编号大于N的Prepare请求，那么他就可以接受这个编号为N的提<br>案。</p>
</blockquote>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>上面的内容中，分别从Proposer和Acceptor对提案的生成和批准两方面来讲解了Paxos算法在提案选定过程中的算法细节，同时也在提案的编号全局唯一的前提下，获得了一个提案选定算法，接下来我们再对这个初步算法做一个小优化，尽可能的忽略Prepare请求</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606201837783.png" alt="image-20220606201837783" style="zoom:80%;">

<pre class="line-numbers language-none"><code class="language-none">如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该
Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通过这个优化，每个Acceptor只需要记住它已经批准的提案的最大编号以及它已经做出Prepare请求响应的提案的最大编号，以便出现故障或节点重启的情况下，也能保证P2c的不变性，而对于Proposer来说，只要它可以保证不会产生具有相同编号的提案，那么就可以丢弃任意的提案以及它所有的运行时状态信息</p>
<h3 id="Paxos算法描述"><a href="#Paxos算法描述" class="headerlink" title="Paxos算法描述"></a>Paxos算法描述</h3><p>综合前面的讲解，我们来对Paxos算法的提案选定过程进行下总结，那结合Proposer和Acceptor对提案的处理逻<br>辑，就可以得到类似于两阶段提交的算法执行过程<br>Paxos算法分为两个阶段。具体如下：</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606201914583.png" alt="image-20220606201914583" style="zoom:80%;">

<ul>
<li>阶段一：<br>(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。<br>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给Proposer，同时该<br>Acceptor承诺不再接受任何编号小于N的提案。</li>
<li>阶段二：<br>(a) 如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针<br>对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。<br>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare<br>请求做出过响应，它就受该提案。</li>
</ul>
<p>当然，实际运行过程中，每一个Proposer都有可能产生多个提案，但只要每个Proposer都遵循如上所述的算法运<br>行，就一定能够保证算法执行的正确性</p>
<h3 id="Learner学习被选定的value"><a href="#Learner学习被选定的value" class="headerlink" title="Learner学习被选定的value"></a>Learner学习被选定的value</h3><p>刚刚我们介绍了如何来选定一个提案，下面我们再来看看：</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202010093.png" alt="image-20220606202010093" style="zoom:80%;">

<p>方案一： </p>
<p>Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准，因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Learner<br>很显然，这种做法虽然可以让Learner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Learner逐<br>个进行一次通信，通信的次数至少为二者个数的乘积</p>
<p>方案二：<br>另一种可行的方案是，我们可以让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定的Learner（称<br>为主Learner）, 各个Learner之间可以通过消息通信来互相感知提案的选定情况，基于这样的前提，当主Learner<br>被通知一个提案已经被选定时，它会负责通知其他的learner<br>在这种方案中，Acceptor首先会将得到批准的提案发送给主Learner,再由其同步给其他Learner.因此较方案一而<br>言，方案二虽然需要多一个步骤才能将提案通知到所有的learner，但其通信次数却大大减少了，通常只是<br>Acceptor和Learner的个数总和，但同时，该方案引入了一个新的不稳定因素：主Learner随时可能出现故障</p>
<p>方案三：<br>在讲解方案二的时候，我们提到，方案二最大的问题在于主Learner存在单点问题，即主Learner随时可能出现故<br>障，因此，对方案二进行改进，可以将主Learner的范围扩大，即Acceptor可以将批准的提案发送给一个特定的<br>Learner集合，该集合中每个Learner都可以在一个提案被选定后通知其他的Learner。这个Learner集合中的<br>Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高</p>
<h3 id="如何保证Paxos算法的活性"><a href="#如何保证Paxos算法的活性" class="headerlink" title="如何保证Paxos算法的活性"></a>如何保证Paxos算法的活性</h3><p>根据前面的内容讲解，我们已经基本上了解了Paxos算法的核心逻辑，那接下来再来看看Paxos算法在实际过程中<br>的一些细节<br>活性：最终一定会发生的事情：最终一定要选定value</p>
<p>假设存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的提案，导致最终陷入死循环，没有<br>value被选定,具体流程如下:</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202108796.png" alt="image-20220606202108796" style="zoom:80%;">

<p>解决：通过选取主Proposer，并规定只有主Proposer才能提出议案。这样一来只要主Proposer和过半的Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准，这样通过选择一个主Proposer，整套Paxos算法就能够保持活性</p>
<h2 id="10-分布式理论：一致性算法-Raft"><a href="#10-分布式理论：一致性算法-Raft" class="headerlink" title="10.分布式理论：一致性算法 Raft"></a>10.分布式理论：一致性算法 Raft</h2><h3 id="什么是Raft-算法"><a href="#什么是Raft-算法" class="headerlink" title="什么是Raft 算法"></a>什么是Raft 算法</h3><p>首先说什么是 Raft 算法：Raft 是一种为了管理复制日志的一致性算法。<br>Raft提供了和Paxos算法相同的功能和性能，但是它的算法结构和Paxos不同。Raft算法更加容易理解并且更容易构建实际的系统。<br>Raft将一致性算法分解成了3模块</p>
<ol>
<li>领导人选举</li>
<li>日志复制</li>
<li>安全性</li>
</ol>
<p>Raft算法分为两个阶段，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。</p>
<h3 id="领导人Leader选举"><a href="#领导人Leader选举" class="headerlink" title="领导人Leader选举"></a>领导人Leader选举</h3><p>Raft 通过选举一个领导人，然后给予他全部的管理复制日志的责任来实现一致性。<br>在Raft中，任何时候一个服务器都可以扮演下面的角色之一：</p>
<ul>
<li>领导者(leader)：处理客户端交互，日志复制等动作，一般一次只有一个领导者</li>
<li>候选者(candidate)：候选者就是在选举过程中提名自己的实体，一旦选举成功，则成为领导者</li>
<li>跟随者(follower)：类似选民，完全被动的角色，这样的服务器等待被通知投票</li>
</ul>
<p>而影响他们身份变化的则是 选举。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202220752.png" alt="image-20220606202220752" style="zoom:80%;">

<p>Raft使用心跳机制来触发选举。当server启动时，初始状态都是follower。每一个server都有一个定时器，超时时<br>间为election timeout（一般为150-300ms），如果某server没有超时的情况下收到来自领导者或者候选者的任何消息，定时器重启，如果超时，它就开始一次选举。<br><a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a> 动画演示<br>下面用图示展示这个过程：<br>初始状态下集群中的所有节点都处于 follower 状态。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202239154.png" alt="image-20220606202239154" style="zoom:80%;">

<p>某一时刻，其中的一个 follower 由于没有收到 leader 的 heartbeat 率先发生 election timeout 进而发起选举。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202253494.png" alt="image-20220606202253494" style="zoom:80%;">

<p>只要集群中超过半数的节点接受投票，candidate 节点将成为即切换 leader 状态。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202303535.png" alt="image-20220606202303535" style="zoom:80%;">

<p>成为 leader 节点之后，leader 将定时向 follower 节点同步日志并发送 heartbeat。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202313610.png" alt="image-20220606202313610" style="zoom:80%;">

<h3 id="节点异常"><a href="#节点异常" class="headerlink" title="节点异常"></a>节点异常</h3><p>集群中各个节点的状态随时都有可能发生变化。从实际的变化上来分类的话，节点的异常大致可以分为四种类型：</p>
<ul>
<li>leader 不可用；</li>
<li>follower 不可用；</li>
<li>多个 candidate 或多个 leader；</li>
<li>新节点加入集群。</li>
</ul>
<h4 id="leader-不可用"><a href="#leader-不可用" class="headerlink" title="leader 不可用"></a>leader 不可用</h4><p>下面将说明当集群中的 leader 节点不可用时，raft 集群是如何应对的。<br>➢ 一般情况下，leade 节点定时发送 heartbeat 到 follower 节点。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202436052.png" alt="image-20220606202436052" style="zoom:80%;">

<p>由于某些异常导致 leader 不再发送 heartbeat ，或 follower 无法收到 heartbeat</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202448883.png" alt="image-20220606202448883" style="zoom:80%;">

<p>当某一 follower 发生 election timeout 时，其状态变更为 candidate，并向其他 follower 发起投票。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202459663.png" alt="image-20220606202459663" style="zoom:80%;">

<p>➢ 当超过半数的 follower 接受投票后，这一节点将成为新的 leader，leader 的步进数加 1 并开始向 follower 同步日志。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202515382.png" alt="image-20220606202515382" style="zoom:80%;">

<p>➢ 当一段时间之后，如果之前的 leader 再次加入集群，则两个 leader 比较彼此的步进数，步进数低的 leader 将切换自己的状态为 follower</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202532252.png" alt="image-20220606202532252" style="zoom:80%;">

<p>➢ 较早前 leader 中不一致的日志将被清除，并与现有 leader 中的日志保持一致。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202542622.png" alt="image-20220606202542622" style="zoom:80%;">

<h4 id="follower-节点不可用"><a href="#follower-节点不可用" class="headerlink" title="follower 节点不可用"></a>follower 节点不可用</h4><p>follower 节点不可用的情况相对容易解决。因为集群中的日志内容始终是从 leader 节点同步的，只要这一节点再<br>次加入集群时重新从 leader 节点处复制日志即可。<br>➢ 集群中的某个 follower 节点发生异常，不再同步日志以及接收 heartbeat。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202611668.png" alt="image-20220606202611668" style="zoom:80%;">

<p>➢ 经过一段时间之后，原来的 follower 节点重新加入集群。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202633527.png" alt="image-20220606202633527" style="zoom:80%;">

<p>➢ 这一节点的日志将从当时的 leader 处同步。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202644021.png" alt="image-20220606202644021" style="zoom:80%;">

<h4 id="多个-candidate-或多个-leader"><a href="#多个-candidate-或多个-leader" class="headerlink" title="多个 candidate 或多个 leader"></a>多个 candidate 或多个 leader</h4><p>在集群中出现多个 candidate 或多个 leader 通常是由于数据传输不畅造成的。出现多个 leader 的情况相对少见，但多个 candidate 比较容易出现在集群节点启动初期尚未选出 leader 的“混沌”时期。<br>➢ 初始状态下集群中的所有节点都处于 follower 状态。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202708367.png" alt="image-20220606202708367" style="zoom:80%;">

<p>➢ 两个节点同时成为 candidate 发起选举。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202720246.png" alt="image-20220606202720246" style="zoom:80%;">

<p>➢ 两个 candidate 都只得到了少部分 follower 的接受投票。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202730132.png" alt="image-20220606202730132" style="zoom:80%;">

<p>➢ candidate 继续向其他的 follower 询问</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202751977.png" alt="image-20220606202751977" style="zoom:80%;">

<p>➢ 由于一些 follower 已经投过票了，所以均返回拒绝接受。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202803329.png" alt="image-20220606202803329" style="zoom:80%;">

<p>➢ candidate 也可能向一个 candidate 询问投票。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202814851.png" alt="image-20220606202814851" style="zoom:80%;">

<p>➢ 在步进数相同的情况下，candidate 将拒绝接受另一个 candidate 的请求。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202828215.png" alt="image-20220606202828215" style="zoom:80%;">

<p>➢ 由于第一次未选出 leader，candidate 将随机选择一个等待间隔（150ms ~ 300ms）再次发起投票</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202839199.png" alt="image-20220606202839199" style="zoom:80%;">
 ➢如果得到集群中半数以上的 

<p>➢ 如果得到集群中半数以上的 follower 的接受，这一 candidate 将成为 leader</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202900720.png" alt="image-20220606202900720" style="zoom:80%;">

<p>➢ 稍后另一个 candidate 也将再次发起投票。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202943659.png" alt="image-20220606202943659" style="zoom:80%;">

<p>➢ 由于集群中已经选出 leader，candidate 将收到拒绝接受的投票。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606202954227.png" alt="image-20220606202954227" style="zoom:80%;">

<p>➢ 在被多数节点拒绝之后，并已知集群中已存在 leader 后，这一 candidate 节点将终止投票请求、切换为<br>follower，从 leader节点同步日志。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606203020555.png" alt="image-20220606203020555" style="zoom:80%;">

<h3 id="日志复制（保证数据一致性）"><a href="#日志复制（保证数据一致性）" class="headerlink" title="日志复制（保证数据一致性）"></a>日志复制（保证数据一致性）</h3><p>日志复制的过程<br>    Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，<br>然后并行的向其他服务器发起 AppendEntries RPC复制日志条目。当这条日志被复制到大多数服务器上，Leader<br>将这条日志应用到它的状态机并向客户端返回执行结果。<br>下图表示了当一个客户端发送一个请求给领导者，随后领导者复制给跟随者的整个过程。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606203049055.png" alt="image-20220606203049055" style="zoom:80%;">

<p>4 个步骤：</p>
<ul>
<li>客户端的每一个请求都包含被复制状态机执行的指令。</li>
<li>leader把这个指令作为一条新的日志条目添加到日志中，然后并行发起 RPC 给其他的服务器，让他们复制这<br>条信息。</li>
<li>跟随者响应ACK,如果 follower 宕机或者运行缓慢或者丢包，leader会不断的重试，直到所有的 follower 最终都复制了所有的日志条目。</li>
<li>通知所有的Follower提交日志，同时领导人提交这条日志到自己的状态机中，并返回给客户端。</li>
</ul>
<p>可以看到，直到第四步骤，整个事务才会达成。中间任何一个步骤发生故障，都不会影响日志一致性</p>
<h1 id="二-分布式系统设计策略"><a href="#二-分布式系统设计策略" class="headerlink" title="二.分布式系统设计策略"></a>二.分布式系统设计策略</h1><p>分布式系统本质是通过低廉的硬件攒在一起以获得更好的吞吐量、性能以及可用性等。<br>在分布式环境下，有几个问题是普遍关心的，我们称之为设计策略：</p>
<ul>
<li>如何检测当前节点还活着？</li>
<li>如何保障高可用？</li>
<li>容错处理</li>
<li>负载均衡</li>
</ul>
<h2 id="1-心跳检测"><a href="#1-心跳检测" class="headerlink" title="1.心跳检测"></a>1.心跳检测</h2><p>在分布式环境中，我们提及过存在非常多的节点（Node），其实质是这些节点分担任务的运行、计算或者程序逻<br>辑处理。那么就有一个非常重要的问题，如何检测一个节点出现了故障乃至无法工作了？</p>
<p>通常解决这一问题是采用心跳检测的手段，如同通过仪器对病人进行一些检测诊断一样。</p>
<p>心跳顾名思义，就是以固定的频率向其他节点汇报当前节点状态的方式。收到心跳，一般可以认为一个节点和现在<br>的网络拓扑是良好的。当然，心跳汇报时，一般也会携带一些附加的状态、元数据信息，以便管理</p>
<p>如图所示，Client请求Server，Server转发请求到具体的Node获取请求结果。Server需要与三个Node节点保持心跳连接，确保Node可以正常工作。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606203250890.png" alt="image-20220606203250890" style="zoom:80%;">

<p>若Server没有收到Node3的心跳时，Server认为Node3失联。但是失联是失去联系，并不确定是否是Node3故<br>障，有可能是Node3处于繁忙状态，导致调用检测超时；也有可能是Server与Node3之间链路出现故障或闪断。所以心跳不是万能的，收到心跳可以确认节点正常，但是收不到心跳也不能认为该节点就已经宣告“死亡”。此时，可以通过一些方法帮助Server做决定： 周期检测心跳机制、累计失效检测机制</p>
<p>周期检测心跳机制<br>Server端每间隔 t 秒向Node集群发起监测请求，设定超时时间，如果超过超时时间，则判断“死亡”。</p>
<p>累计失效检测机制<br>在周期检测心跳机制的基础上，统计一定周期内节点的返回情况（包括超时及正确返回），以此计算节点的“死<br>亡”概率。另外，对于宣告“濒临死亡”的节点可以发起有限次数的重试，以作进一步判断。</p>
<p>通过周期检测心跳机制、累计失效检测机制可以帮助判断节点是否“死亡”，如果判断“死亡”，可以把该节点踢出集群</p>
<h2 id="2-高可用设计"><a href="#2-高可用设计" class="headerlink" title="2.高可用设计"></a>2.高可用设计</h2><p>高可用(High Availability)是系统架构设计中必须考虑的因素之一,通常是指,经过设计来减少系统不能提供服务的时<br>间 .</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606203343263.png" alt="image-20220606203343263" style="zoom:80%;">

<p>系统高可用性的常用设计模式包括三种：主备（Master-SLave）、互备（Active-Active）和集群（Cluster）模<br>式。<br>1.主备模式 主备模式就是Active-Standby模式，当主机宕机时，备机接管主机的一切工作，待主机恢复正常后，按使用者的设定以自动（热备）或手动（冷备）方式将服务切换到主机上运行。在数据库部分，习惯称之为MS模<br>式。MS模式即Master/Slave模式，这在数据库高可用性方案中比较常用，如MySQL、Redis等就采用MS模式实现主从复制。保证高可用，如图所示。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606203406354.png" alt="image-20220606203406354" style="zoom:80%;">

<p>MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p>
<p>2.互备模式 互备模式指两台主机同时运行各自的服务工作且相互监测情况。在数据库高可用部分，常见的互备是<br>MM模式。MM模式即Multi-Master模式，指一个系统存在多个master，每个master都具有read-write能力，会根据时间戳或业务逻辑合并版本。</p>
<p>我们使用过的、构建过的MySQL服务绝大多数都是Single-Master，整个拓扑中只有一个Master承担写请求。比<br>如，基于Master-Slave架构的主从复制，但是也存在由于种种原因，我们可能需要MySQL服务具有Multi-Master的特性，希望整个拓扑中可以有不止一个Master承担写请求</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606203434182.png" alt="image-20220606203434182" style="zoom:80%;">

<p>3.集群模式<br>集群模式是指有多个节点在运行，同时可以通过主控节点分担服务请求。如Zookeeper。集群模式需要解决主控节点本身的高可用问题，一般采用主备模式。</p>
<h2 id="3-容错性"><a href="#3-容错性" class="headerlink" title="3.容错性"></a>3.容错性</h2><p>容错顾名思义就是IT系统对于错误包容的能力<br>容错的处理是保障分布式环境下相应系统的高可用或者健壮性，一个典型的案例就是对于缓存穿透 问题的解决方<br>案。<br>我们来具体看一下这个例子，如图所示</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606203503673.png" alt="image-20220606203503673" style="zoom:80%;">

<p>问题描述：</p>
<p>我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据<br>库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查<br>询DB，这样缓存就失去了意义，在流量大时，或者有人恶意攻击</p>
<p>如频繁发起为id为“-1”的条件进行查询，可能DB就挂掉了。<br>那这种问题有什么好办法解决呢？</p>
<p>一个比较巧妙的方法是，可以将这个不存在的key预先设定一个值。比如，key=“null”。在返回这个null值的时候，我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是null，则可以认为这时候key有值了，从而避免了透传到数据库，把大量的类似请求挡在了缓存之中。</p>
<h2 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4.负载均衡"></a>4.负载均衡</h2><p>负载均衡：其关键在于使用多台集群服务器共同分担计算任务，把网络请求及计算分配到集群可用的不同服务器节<br>点上，从而达到高可用性及较好的用户操作体验。<br>如图，不同的用户User1、User2、User3访问应用，通过负载均衡器分配到不同的节点。</p>
<img src="https://cdn.jsdelivr.net/gh/kuangtianyu/img/img/image-20220606203549827.png" alt="image-20220606203549827" style="zoom:80%;">

<p>负载均衡器有硬件解决方案，也有软件解决方案。硬件解决方案有著名的F5，软件有LVS、HAProxy、Nginx等。<br>以Nginx为例，负载均衡有以下几种策略：</p>
<ul>
<li>轮询：即Round Robin，根据Nginx配置文件中的顺序，依次把客户端的Web请求分发到不同的后端服务器。</li>
<li>最少连接：当前谁连接最少，分发给谁。</li>
<li>IP地址哈希：确定相同IP请求可以转发给同一个后端节点处理，以方便session保持。</li>
<li>基于权重的负载均衡：配置Nginx把请求更多地分发到高配置的后端服务器上，把相对较少的请求分发到低配服务器。</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">帅枫</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://kuangtf.github.io/2022/06/07/fen-bu-shi/fen-bu-shi-zong-jie/">http://kuangtf.github.io/2022/06/07/fen-bu-shi/fen-bu-shi-zong-jie/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">帅枫</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%80%BB%E7%BB%93/">
                                    <span class="chip bg-color">分布式总结</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">先赞后看，养成习惯</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/06/15/bing-fa/yuan-zi-cao-zuo-de-shi-xian-yuan-li/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/medias/featureimages/5.jpg" class="responsive-img" alt="原子操作的实现原理">
                        
                        <span class="card-title">原子操作的实现原理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-06-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%B9%B6%E5%8F%91/" class="post-category">
                                    并发
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/">
                        <span class="chip bg-color">原子操作</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/06/06/jvm/hotspot-de-suan-fa-xi-jie-shi-xian/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/medias/featureimages/9.jpg" class="responsive-img" alt="HotSpot的算法细节实现">
                        
                        <span class="card-title">HotSpot的算法细节实现</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-06-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JVM/" class="post-category">
                                    JVM
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%E5%AE%9E%E7%8E%B0/">
                        <span class="chip bg-color">HotSpot的算法细节实现</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Maple<br />'
            + '文章作者: Maple<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="kugou"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="sitetime"></span>
            <br>
            
                <span id="year">2019-2022</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Maple</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">669.7k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/kuangtf" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1162849426@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1162849426" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1162849426" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kuangtf" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kuangtf" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2021, 10, 01, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " +diffYears+" 年 "+diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="https://cdn.jsdelivr.net/gh/kuangtf/kuangtf.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
